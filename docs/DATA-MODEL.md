# MemoBrain Data Model

## Core Entities

### 1. ReasoningNode

The fundamental unit of memory storage.

```python
@dataclass
class ReasoningNode:
    node_id: int                    # Unique identifier (auto-incremented)
    kind: NodeKind                  # Type of reasoning step
    thought: str                    # Content (often JSON array of Notes)
    related_turn_ids: List[int]     # Links to conversation turns
    active: Union[bool, str]        # True, False, or "Flushed"
```

#### NodeKind Values

| Kind | Description | Created By |
|------|-------------|------------|
| `"task"` | Original user question / main objective | `init_memory()` |
| `"subtask"` | Decomposed sub-problem | LLM patch |
| `"evidence"` | Factual answer or conclusion | LLM patch |
| `"summary"` | Synthesized node from fold operation | `recall()` |

#### Active States

| State | Meaning |
|-------|---------|
| `True` | Node is active and visible |
| `False` | Node was folded into summary |
| `"Flushed"` | Node was explicitly removed |

---

### 2. Edge

Represents relationships between nodes.

```python
@dataclass
class Edge:
    src: str      # Source node ID
    dst: str      # Destination node ID
    rationale: str  # Explanation of relationship
```

#### Relationship Types (Implicit via rationale)

| Type | Direction | Usage |
|------|-----------|-------|
| `decompose` | task → subtask | Breaking down a problem |
| `refine` | subtask → subtask | Making more specific |
| `support` | evidence → task/subtask | Answer or conclusion |

---

### 3. Notes

Content structure within `thought` field.

```python
class Notes(BaseModel):
    role: str      # Participant identifier
    content: str   # Message content
```

#### Standard Roles

| Role | Meaning |
|------|---------|
| `"assistant"` | Agent's reasoning/action |
| `"user"` | Tool response / feedback |
| `"system"` | System-generated content |

#### Custom Roles (Multi-Agent)

```json
{"role": "Agent_Analyst", "content": "..."}
{"role": "Agent_Developer", "content": "..."}
{"role": "User_R2d2", "content": "..."}
```

---

## Operation Schemas

### MemoryPatch (from LLM)

Generated by `memorize()` when processing new episodes.

```python
class MemoryPatch(BaseModel):
    add_nodes: List[AddNodeOp]  # New nodes to create
    add_edges: List[AddEdgeOp]  # New relationships
```

### AddNodeOp

```python
class AddNodeOp(BaseModel):
    tmp_id: str           # Temporary ID (e.g., "tmp1")
    kind: NodeKind        # "subtask" or "evidence" only
    thought: List[Notes]  # Content as Notes array
```

### AddEdgeOp

```python
class AddEdgeOp(BaseModel):
    src: str              # Node ID or tmp_id
    dst: str              # Node ID or tmp_id
    rationale: str        # Optional explanation
```

---

### FlushAndFoldOp (from LLM)

Generated by `recall()` for optimization.

```python
class FlushAndFoldOp(BaseModel):
    flush_ops: List[FlushOp]  # Nodes to remove
    fold_ops: List[FoldOp]    # Nodes to compress
```

### FlushOp

```python
class FlushOp(BaseModel):
    id: int           # Node ID to flush
    rationale: str    # Why this node is redundant
```

### FoldOp

```python
class FoldOp(BaseModel):
    ids: List[int]        # Node IDs to fold together
    notes: List[Notes]    # Summary content
    rationale: str        # Why these nodes can be folded
```

---

## Graph Visualization

### Example Structure

```
Node 1 [task] "Research NestJS best practices"
├── Node 2 [subtask] "Find architecture patterns"
│   ├── Node 4 [evidence] "Modular architecture found"
│   └── Node 5 [evidence] "DDD patterns documented"
├── Node 3 [subtask] "Find testing strategies"
│   └── Node 6 [evidence] "Jest + E2E recommended"
└── Node 7 [summary] (folded from 4,5) "Architecture summary"
```

### JSON Representation

```json
{
  "nodes": {
    "1": {
      "node_id": 1,
      "kind": "task",
      "thought": "Research NestJS best practices",
      "related_turn_ids": [0, 1],
      "active": true
    },
    "2": {
      "node_id": 2,
      "kind": "subtask",
      "thought": [
        {"role": "assistant", "content": "Searching for architecture..."},
        {"role": "user", "content": "Results: modular patterns..."}
      ],
      "related_turn_ids": [2, 3],
      "active": true
    }
  },
  "edges": [
    {"src": 1, "dst": 2, "rationale": "decompose task"}
  ]
}
```

---

## Storage Format

### Memory Snapshot (JSON)

```json
{
  "nodes": {
    "<node_id>": {
      "node_id": <int>,
      "kind": "<task|subtask|evidence|summary>",
      "thought": "<string or JSON array>",
      "related_turn_ids": [<int>, ...],
      "active": <true|false|"Flushed">
    }
  },
  "edges": [
    {
      "src": "<node_id>",
      "dst": "<node_id>",
      "rationale": "<string>"
    }
  ]
}
```

### Messages Array

Internal `self.messages` stores raw conversation:

```python
[
    {"role": "assistant", "content": "..."},
    {"role": "user", "content": "..."},
    {"role": "assistant", "content": "..."},
    {"role": "user", "content": "..."},
    # ...
]
```

---

## Index Reference

### By Node Kind

| Query | Method |
|-------|--------|
| All tasks | `[n for n in graph.nodes.values() if n.kind == "task"]` |
| All evidence | `[n for n in graph.nodes.values() if n.kind == "evidence"]` |
| Active nodes | `[n for n in graph.nodes.values() if n.active is True]` |
| Leaf nodes | `graph.get_leaf_node_ids()` |

### By Relationship

| Query | Approach |
|-------|----------|
| Children of node X | Filter edges where `dst == X` |
| Parents of node X | Filter edges where `src == X` |
| Path to root | Traverse edges recursively |
